\chapter{Оптимизации в векторном компиляторе}\label{ch:lowering}

\section{Метод ступенчатого понижения}\label{sec:lowering/passes}

Место ступенчатого понижения в списке трансформаций графического компилятора выбирается из следующих соображений.

\begin{enumerate}
\item Должна отработать трансляция из SPIRV.
\item Также должны отработать основные высокоуровневые платформенно-независимые оптимизации.
\item При этом не должны быть легализованы инструкции и не должна быть начата кодогенерация.
\end{enumerate}

\begin{figure}[ht]
    \centerfloat{
        \includegraphics[scale=0.4]{Vladimirov/images/highlevel-mgr.pdf}
    }
    \caption{Высокоуровневый список трансформаций}\label{fig:highlevel-mgr}
\end{figure}

Высокоуровневая схема менеджера пассов представлена на рисунке~\cref{fig:highlevel-mgr}. Выбор места обосновывается как результатами экспериментов, так и следующими соображениями.

\begin{itemize}
\item Трансформация операций копирования возможна только после того как эта операция распознана как идиома, то есть после оптимизаций над высокоуровневым IR.
\item Разрешение адресных пространств может породить много платформенно-зависимого кода и должно идти до оптимизаций над легализованными инструкциями.
\item Трансформация приватных операций с памятью и выделение спиллов должно идти после цикловых оптимизаций, но до вставки пролога и эпилога.
\item TODO: расписать все соображения.
\end{itemize}

Важно подчеркнуть, что метод применим к любой системе и любому уровню промежуточного представления с минимальными модификациями. 

\begin{figure}[ht]
    \centerfloat{
        \includegraphics[scale=0.4]{Vladimirov/images/passmgr.pdf}
    }
    \caption{Детальный список трансформаций}\label{fig:passmgr}
\end{figure}

Детальный список трансформаций представлен на рисунке~\cref{fig:passmgr}. В нём есть два вида трансформаций -- обязательные легализации необходимые для представления высокоуровневых конструкций для векторной системы команд и необязательные оптимизации, которые оптимизируют представление, делая его более подходящим для высокоэффективных вычислений.

\subsection{Высокоуровневое представление}\label{subsec:lowering/passes/highlevel}

Представление на IR высокого уровня (HIR, high-level IR) после высокоуровневого языка содержит адресные пространства и трансформации типов указателей между типами пространств адресов. Кроме того там используются обобщённые операции загрузки и сохранения.

\begin{ListingEnv}[!h]
    \captiondelim{ } 
    \caption{Пример представления на HIR}\label{lst:lowering/irrep}
    \begin{Verb}
%4 = tail call i32 @llvm.genx.group.id.x()
%5 = extractelement <3 x i32> %local.size, i32 0
%6 = mul i32 %4, %5
%7 = extractelement <3 x i32> %local.id, i32 0
%8 = add i32 %6, %7
    \end{Verb}
\end{ListingEnv}

Листинг~\cref{lst:lowering/irrep} показывет загрузку вектора группового идентификатора, умножение на локальный размер и прибавление локального идентификатора как высокоуровневые операции.

\subsection{Инварианты трансформаций}\label{subsec:lowering/passes/invariants}

Предлагаемые трансформации имеют инварианты применения, представленные на рисунке~\cref{fig:highlevel-mgr-inv}. Поскольку предлагаемая методология является достаточно общей, важно понимать в каких случаях они могут быть ослаблены или усилены.

\begin{figure}[ht]
    \centerfloat{
        \includegraphics[scale=0.4]{Vladimirov/images/highlevel-mgr-inv.pdf}
    }
    \caption{Инварианты при трансформациях}\label{fig:highlevel-mgr-inv}
\end{figure}

После оптимизаций над высокоуровневым представлением, память не обязательно представляется исключительно обобщёнными операциями. Например программист может написать явный векторный код, работающий с векторными загрузками из памяти. В этом случае высокоуровневые оптимизации вряд ли будут способны обработать такую операцию и на вход каскадного понижения она попадёт в неизменном виде.

\subsection{Представление на регионах}\label{subsec:lowering/passes/lowlevel}

Физическое представление на регионах может существовать во многих формах. Например в графическом компиляторе Intel оно существует в виде G4IR, в виде VISA и в виде XeISA. 

\begin{ListingEnv}[!h]
    \captiondelim{ } 
    \caption{Пример физического представления}\label{lst:lowering/regrep}
    \begin{Verb}
mov (1|M0) r5.0<1>:uq r2.2<0;1,0>:uq
send (8|M0) r1 r5 0xC 0x021D0AFF
mov (1|M0) r6.0<1>:uq r2.3<0;1,0>:uq
send (8|M0) r3 r6 0xC 0x021D0AFF
add (8|M0) r4.0<1>:f r1.0<8;8,1>:f r3.0<8;8,1>:f
mov (1|M0) r7.0<1>:uq r2.1<0;1,0>:uq
sends (8|M0) r7 r4 0x4C 0x020D42FF
    \end{Verb}
\end{ListingEnv}

Листинг~\cref{lst:lowering/regrep} показывает типичное представление на регионах того же самого кода, который высокоуровнево представлен на листинге~\cref{lst:lowering/irrep}.

\section{Разбиение структур}\label{sec:lowering/splitter}

Перед описанием алгоритма разбиения определим правила, по которым мы будем выделять части агрегатных типов для векторизации.

В стандарте C++ существует концепция скалярного типа.
Скалярными называются арифметические типы, типы перечислений, указатели и cv-квалифицрованные версии перечисленных типов.
Назовём \emph{базовым} скалярный тип, поддерживаемый данной оптимизацией.
В это множество входят также векторные типы, которых нет в C++, но которые есть в LLVM IR. 
В это множество не входят, например, указатели.
Определение сознательно является несколько нечетким, чтобы заложить возможность будущего расширения.
Алгоритм ниже не разбивает базовые типы.

Назовём \emph{примитивным} либо базовый тип, либо агрегатный тип, у которого типы всех элементов одинаковы и примитивны.
Такой тип нет необходимости делить, так как объекты таких типов могут быть легко переделаны в вектора фазой aggregate lowering, которая представлена в векторном оптимизаторе IGC.
Для алгоритма нет разницы между примитивным типом и базовым, из которого этот примитивный тип состоит, поэтому примитивный всегда будет сводиться к базовому. Например, \verb|< 3 x [ 5 x int]>| будет эквивалентен типу \verb|int|.

Целью алгоритма разбиения структур является приведение всех структур в модуле (например в модуле LLVM IR) к структурам примитивного типа с обязательным сохранением поведения исходной программы в рамках as-if rule.

Фаза разбиения структур в векторном компиляторе разрабатывалась специально для ISPC -- компилятора для SPMD~(single program, multiple data).
При этом алгоритм сам по себе может быть использован в более широких классах оптимизаторов, даже не основанных на LLVM.
Оптимизация работает над LLVM модулем и должна применятся до векторизации.

Разбиение невозможно, если:
\begin{enumerate}
\item элемент структуры является указателем на другую нетривиальную структуру, в том числе на саму себя.
\item на структуру взят указатель.
\end{enumerate}

Первое ограничение появляется из-за использования версии LLVM, в которой ещё не были введены opaque указатели.
Собственноручная поддержка таких указателей приводит к сильному разрастанию получаемого модуля и невозможности применения других оптимизаций.
По этой же причине была невозможна поддержка передачи структур в пользовательские функции.
Второе ограничение связано с тем, что замена кода работы с указателем на аналогичный код с поделёнными структурами может привести к значительному увеличению количества инструкций.

\textbf{Описание алгоритма}

\textbf{Шаг 1. Сбор информации о структурах в модуле}

Информация о структуре хранится в виде хэш-таблицы, где ключ -- это примитивный тип элемента, а значения -- элементы, соответствующие этому типу. Структура в дальнейшем будет делиться как раз по элементам этой хэш-таблицы, так как ключам будет соответствовать примитивный тип, а значениям -- элементы будущей структуры. 
Количество ключей минус один -- столько структур необходимо будет сгенерировать.
Соответственно, если у структуры существует только один примитивный тип, то данную структуру делить нет необходимости, так как она сама является примитивной.

\textbf{Шаг 2. Построение графа вложенности структур}

Так как элементами структуры могут быть другие структуры, то такие ситуации необходимо разрешать.
Граф строится следующим образом: вершине $A$ соответствует структура \%A.
Ребро от вершины $C$ в вершину $A$ проводится в том случае, если структура, соответствующая вершине $A$, вложена в структуру, соответствующую вершине $C$.
Назовём головой графа($Head$) вершины, которые соответствуют структурам, не вложенным ни в какие другие структуры.
Голов графа может быть как одна, так и несколько.

\textbf{Шаг 3. Обработка графа вложенности структур}

Обработка графа начинается с головы, однако деление -- с самой нижней вершины.
Все нижние вершины всегда характеризуются тем, что структуры, связанные с ними содержат элементы только примитивных типов, а значит данные структуры могут быть поделены.
При обработке вершины графа возможны два варианта.
Первое -- если вершина отвечает за примитивную структуру, то в делении нет необходимости и данная вершина удаляется из графа.
Второе -- структура, отвечающая за вершину была поделена.
Тогда нужно заменить во всех структурах, в которые была вложена данная, все элементы, отвечающие за данную структуру, на новые элементы с поделёнными структурами.
Во время замены элементов появляются промежуточные представления структур, которые затем необходимо удалить.
После обработки вершины она удаляется, поэтому все структуры будут обработаны тогда, когда весь граф удалится.

\textbf{Шаг 4. Обработка и замена инструкций}

Обработка инструкций всегда начинается с инструкции выделения памяти на стековом фрейме под структуру (AI -- alloca в LLVM IR).
Далее единственными допустимыми пользователями инструкций выделения памяти являются только инструкции обращения к элементу агрегата (GEP -- getelementptr).
Однако в нашей реализации были допущены инструкции приведения (bitcast) и ptrtoint (PTI) только с определёнными шаблонами использования.
В случае bitcast единственными пользователями могут быть только интринсики lifetime.start/end.
% TODO убрать зависимость от ISPC FE в описании алгоритма
В случае ptrtoint фронтенд ISPC вместо доступа к нулевому элементу структуры через getelementptr использует указатель на структуру.
Данный подход необходимо было поддерживать, поэтому в анализе ptrtoint проверяется соответствие шаблону вычисления указателя из следующих инструкций: insertelement, shufflevector, add и read/write.
В случае если результатом обращения к элементу является примитивный тип, то эта инструкция заменяется на эквивалентную с другим операндом и новой цепочкой индексов.
Если результатом является уже разбитая структура, то будут сгенерированы столько новых обращений, на сколько структур была разбита исходная.

\section{Восстановление векторного потока управления}\label{sec:lowering/simdcf}

TODO: Тут про определение региона

После определения SIMD CF региона можно свести задачу поиска заранее оговоренных конструкций к поиску SIMD CF регионов самого внешнего уровня вложенности, после чего искать вложенные SIMD CF регионы.

Шаг 1. Поиск условного перехода, похожего на векторный поток управления. Для
каждого базового блока проверяется его терминатор. Если это инструкция условного
перехода, то проверяется его условие, в противном случае конструкция не является
SIMD CF регионом. Если условием является результат вызова одного из обозначенных
ранее интринсиков, то идет переход к шагу 2.

Шаг 2. Проверяется структура потока управления и происходит попытка сопоставить
его либо с SIMD CF if/else, либо с SIMD CF циклом. Если сопоставление с одним из
заданных паттернов невозможно, то конструкция не является SIMD CF регионом. В
противном случае происходит переход к шагу 3.

Шаг 3. Проверка маскирования побочных эффектов. Для каждой инструкции, у которой
есть побочные эффекты проводится проверка, является ли такая инструкция
маскирована и если она маскирована, то проверяется, совпадает ли маска для
данной инструкции с условием перехода в эту дугу. Для вложенных регионов
проверяется, является ли маска данного региона подмножеством маски внешнего
региона. Если проверка неудачная - данный регион не является SIMD CF регионом.

Дополнение к шагу 3 для цикла. Проверяются фи-узлы для индуктивностей и пересчет
маски для каждого цикла. Если проверка неудачная - данный регион не является
SIMD CF регионом. В противном случае идет переход к шагу 4.

Дополнение к шагу 3 для if-else. Если кроме if также имеется else, то происходит
проверка, являются ли маски if и else строго противоположны друг другу. Если
проверка неудачная - данный регион не является SIMD CF регионом. В противном
случае идет переход к шагу 4.

Шаг 4. Данный регион является SIMD CF регионом. Аналогично происходит поиск
вложенных SIMD CF регионов для данного региона.

В псевдокоде данный алгоритм будет выглядеть как показано на листинге~\ref{lst:simdcf-analysis}

После сбора всей информации о SIMD CF регионах начинается их оптимизирующая трансформация.

TODO: картинки и трансформация

\FloatBarrier