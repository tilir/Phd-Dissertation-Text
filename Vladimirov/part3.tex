\chapter{Реализация и результаты экспериментов}\label{ch:results}

\section{Инфраструктура компилятора LLVM}\label{sec:results/llvm}

Тут про то что LLVM это индустриальный стандарт.

\subsection{Особенности LLVM IR}\label{subsec:results/llvm/ir}

Одним из сильных преимуществ LLVM является промежуточное машинно-независимое представление кода (\textit{Intermediate Representation -- IR}), которое использует миддлэнд для оптимизаций (и которое является выходным форматом для фронтенда и входным для бэкенда). Промежуточное представление LLVM может использоваться в трёх разных формах: как набор структур данных для представления кода в памяти во время компиляции, сериализовываться в виде бинарного кода для хранения на диске (\textit{LLVM bitcode}), и в текстовом виде для удобного чтения и анализа. Все эти формы LLVM IR являются эквивалентными. На самом высоком уровне LLVM оперирует с модулями, что к примеру соответствует концепции единицы трансляции (\textit{translation unit}) языков C и C++. Каждый модуль состоит из глобальных переменных и функций (идентификаторы глобальных объектов всегда начинаются с символа '@'), а также из таблицы метаданных. Объявление функции начинается со слова declare и содержит возвращаемый тип, имя функции, список аргументов и может содержать некоторые опциональные атрибуты; определение функции начинается со слова define и помимо прочего ещё содержит список базовых блоков, которые образуют CFG. Первый блок всегда является точкой входа и не может иметь предшественников (и поэтому также не может иметь $\varphi$-функции). В свою очередь каждый базовый блок начинается с опциональной метки (если она не указана явно, метка с номером назначается автоматически) и списка инструкций, которые заканчиваются инструкцией-терминатором (такой как инструкция перехода или возврат из функции). LLVM IR использует SSA-представление, и это означает, что инструкция может отождествляться со значением которое оно определяет (так как оно единственное). Идентификаторы локальных объектов (такие как значения инструкций) начинаются с символа '\%'. $\varphi$-функции представляются в виде отдельных инструкций (PHINode), которые должны следовать в начале базового блока перед всеми остальными инструкциями.

\bigskip

\begin{lstlisting}[language=llvm, caption=Пример LLVM IR]
; Example of factorial:
; int factorial(int n) {
;  return n ? n * factorial(n - 1) : 1;
; }

define i32 @factorial(i32) {
entry:
  %ne = icmp ne i32 %0, 0
  br i1 %ne, label %then, label %exit

then:   ; preds = %entry
  %sub = sub i32 %0, 1
  %2 = call i32 @factorial(i32 %sub)
  %mult = mul i32 %0, %2
  br label %exit

exit: ; preds = %entry, %then
  %res = phi i32 [ 1, %entry ], [ %mult, %then ]
  ret i32 %res
}
\end{lstlisting}

LLVM IR является строго типизированным, что позволяет осуществлять напрямую некоторые типы оптимизаций. В качестве базовых типов присутствуют целочисленный тип (iN, где N -- количество бит, например i32), типы чисел с плавающей запятой (half, float, double, а также некоторые платформо-специфичные, например x86\_fp80), указатели вида <type> * (указатели на конкретный тип) и недавно добавленные в LLVM <<прозрачные>> (opaque) указатели без типа (обозначаются ptr), а также векторные типы (синтаксис <NumElems x ElemType>, например <8 x i32>). Агрегатными типами являются массивы (синтаксис [NumElems x ElemType], например [40 x i8]) и структуры (синтаксис type { <type list> }, например \{float, i8, i32\}).

\subsection{Платформенно независимые оптимизации}\label{subsec:results/llvm/opts}

Тут про то как хорошо LLVM оптимизирует циклы.

\section{Реализация в IGC}\label{sec:results/igc}

Тут про IGC

\section{Методология замеров}\label{sec:results/measures}

Тут про замеры графических шейдеров

\section{Результаты замеров}\label{sec:results/results}

\subsection{Результаты ступенчатого понижения}\label{subsec:results/results/lowering}

Результаты сведены в таблицу~\cref{tab:results/lowering}.

\begin{table}
    \centering
    \captionsetup{justification=centering}
    \caption{Результаты ступенчатого понижения}\label{tab:results/lowering}
    \begin{tabular}{llc|llc}
        \toprule
        Бенчмарк & Результат & Результат \\
        \midrule
        Первый   & \verb|+|  & \verb|+|  \\
        Второй   & \verb| |  & \verb|+|  \\
        Третий   & \verb|+|  & \verb| |  \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{Результаты разбиения структур}\label{subsec:results/results/splitter}

Для тестирования алгоритма разбиения структур использовались приложения из открытого стека рендеринга Intel (OSPray, Embree). Была оценена корректность алгоритма (прошли все тесты) и его положительное влияние на производительность скомпилированной программы.

Результаты сведены в таблицу~\cref{tab:results/splitter}.

\begin{table}
    \centering
    \captionsetup{justification=centering}
    \caption{Результаты разбиения структур}\label{tab:results/splitter}
    \begin{tabular}{llc|llc}
        \toprule
        Бенчмарк & Результат & Результат \\
        \midrule
        Первый   & \verb|+|  & \verb|+|  \\
        Второй   & \verb| |  & \verb|+|  \\
        Третий   & \verb|+|  & \verb| |  \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{Результаты восстановления векторного потока управления}\label{subsec:results/results/simdcf}

Результаты сведены в таблицу~\cref{tab:results/simdcf}.

\begin{table}
    \centering
    \captionsetup{justification=centering}
    \caption{Результаты восстановления векторного потока управления}\label{tab:results/simdcf}
    \begin{tabular}{llc|llc}
        \toprule
        Бенчмарк & Результат & Результат \\
        \midrule
        Первый   & \verb|+|  & \verb|+|  \\
        Второй   & \verb| |  & \verb|+|  \\
        Третий   & \verb|+|  & \verb| |  \\
        \bottomrule
    \end{tabular}
\end{table}

\section{Выводы}\label{sec:results/outcome}

В третьей главе описываются детали реализации и результаты экспеиментов.

Сначала описывается компиляторная инфраструктура LLVM в которой далее проводятся все эксперименты. Далее описываются особенности графического компилятора IGC и его место в графическом стеке. Отдельно рассматриваются вопросы замеров результатов исполнения шейдерного кода и описывается методология их получения и аппаратная поддержка для этого в современных архитектурах.

Далее описываются основные результаты экспериментов. Результаты применения метода ступенчатого понижения состоят в функциональной корректности работы пакетов тестов. Результаты алгоритмов разбиения структур и восстановления векторного потока управления это улучшение производительности приложений.

\FloatBarrier