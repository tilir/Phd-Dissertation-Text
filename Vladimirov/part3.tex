\chapter{Реализация и результаты экспериментов}\label{ch:results}

\section{Инфраструктура компилятора LLVM}\label{sec:results/llvm}

Тут про то что LLVM это индустриальный стандарт \cite{lattner2005llvm}.

Компиляторная инфраструктура LLVM часто используется в HPC проектах, см. \cite{tian2016llvm} и \cite{tian2017llvm}.

LLVM поддерживает много уровней машинного представления \cite{racordon2021asts}.

В конмпиляторной инфраструктуре LLVM заложена достаточная гибкость, чтобы использовать как высокоуровневые оптимизации над промежуточным представлением, так и низкоуровневые, специфичные для конкретных языков программирования \cite{lee2018reconciling}.

\subsection{Особенности LLVM IR}\label{subsec:results/llvm/ir}

Одним из сильных преимуществ LLVM является промежуточное машинно-независимое представление кода (\textit{Intermediate Representation -- IR}), которое использует миддлэнд для оптимизаций (и которое является выходным форматом для фронтенда и входным для бэкенда). Промежуточное представление LLVM может использоваться в трёх разных формах: как набор структур данных для представления кода в памяти во время компиляции, сериализовываться в виде бинарного кода для хранения на диске (\textit{LLVM bitcode}), и в текстовом виде для удобного чтения и анализа. Все эти формы LLVM IR являются эквивалентными. На самом высоком уровне LLVM оперирует с модулями, что к примеру соответствует концепции единицы трансляции (\textit{translation unit}) языков C и C++. Каждый модуль состоит из глобальных переменных и функций (идентификаторы глобальных объектов всегда начинаются с символа '@'), а также из таблицы метаданных. Объявление функции начинается со слова declare и содержит возвращаемый тип, имя функции, список аргументов и может содержать некоторые опциональные атрибуты; определение функции начинается со слова define и помимо прочего ещё содержит список базовых блоков, которые образуют CFG. Первый блок всегда является точкой входа и не может иметь предшественников (и поэтому также не может иметь $\varphi$-функции). В свою очередь каждый базовый блок начинается с опциональной метки (если она не указана явно, метка с номером назначается автоматически) и списка инструкций, которые заканчиваются инструкцией-терминатором (такой как инструкция перехода или возврат из функции). LLVM IR использует SSA-представление, и это означает, что инструкция может отождествляться со значением которое оно определяет (так как оно единственное). Идентификаторы локальных объектов (такие как значения инструкций) начинаются с символа '\%'. $\varphi$-функции представляются в виде отдельных инструкций (PHINode), которые должны следовать в начале базового блока перед всеми остальными инструкциями.

\begin{ListingEnv}[!h]
    \captiondelim{ } 
    \caption{Пример LLVM IR}\label{lst:results/llvmir}
    \begin{lstlisting}[language=llvm]
; Example of factorial:
; int factorial(int n) {
;  return n ? n * factorial(n - 1) : 1;
; }

define i32 @factorial(i32) {
entry:
  %ne = icmp ne i32 %0, 0
  br i1 %ne, label %then, label %exit

then:   ; preds = %entry
  %sub = sub i32 %0, 1
  %2 = call i32 @factorial(i32 %sub)
  %mult = mul i32 %0, %2
  br label %exit

exit: ; preds = %entry, %then
  %res = phi i32 [ 1, %entry ], [ %mult, %then ]
  ret i32 %res
}
    \end{lstlisting}
\end{ListingEnv}

На листинге~\cref{lst:results/llvmir} приведен пример LLVM IR. Это промежуточное представление является строго типизированным, что позволяет осуществлять напрямую некоторые типы оптимизаций. В качестве базовых типов присутствуют целочисленный тип ($i_N$, где $N$ -- количество бит, например $i_32$), типы чисел с плавающей запятой (half, float, double, а также некоторые платформо-специфичные, например x86\_fp80), указатели вида \lstinline!<type> *! (указатели на конкретный тип) и недавно добавленные в LLVM <<прозрачные>> (opaque) указатели без типа (обозначаются ptr), а также векторные типы (синтаксис \lstinline!<NumElems x ElemType>!, например \lstinline!<8 x i32>!). Агрегатными типами являются массивы (синтаксис \lstinline![NumElems x ElemType]!, например \lstinline![40 x i8]!) и структуры (синтаксис \lstinline!type { <type list> }!, например \lstinline!{float, i8, i32}!).

\subsection{Платформенно независимые оптимизации}\label{subsec:results/llvm/opts}

Тут про то как хорошо LLVM оптимизирует циклы.
\cite{sarkar2000optimized}

Существенной проблемой является неопределенное поведение, проникающее из языков высокого уровня. К счастью в LLVM IR есть эффективные средства работы с таким поведением \cite{lee2017taming}.

\section{Реализация в IGC}\label{sec:results/igc}

Тут про IGC в целом

\subsection{Особенности промежуточного представления в IGC}\label{subsec:results/igc/ir}

Для эффективного распределения регистров, IGC использует ещё более низкоуровневое представление -- G4IR \cite{chen2018register}.

\subsection{Детали обработки разбиения структур в IGC}\label{subsec:results/igc/splitted}

Обработка инструкций всегда начинается с инструкции выделения памяти на стековом фрейме под структуру (AI -- alloca в LLVM IR).
Далее единственными допустимыми пользователями инструкций выделения памяти являются только инструкции обращения к элементу агрегата (GEP -- getelementptr).
Однако в нашей реализации были допущены инструкции приведения (bitcast) и ptrtoint (PTI) только с определёнными шаблонами использования.
В случае bitcast единственными пользователями могут быть только интринсики lifetime.start/end.
% TODO убрать зависимость от ISPC FE в описании алгоритма
В случае ptrtoint фронтенд ISPC вместо доступа к нулевому элементу структуры через getelementptr использует указатель на структуру.
Данный подход необходимо было поддерживать, поэтому в анализе ptrtoint проверяется соответствие шаблону вычисления указателя из следующих инструкций: insertelement, shufflevector, add и read/write.
В случае если результатом обращения к элементу является примитивный тип, то эта инструкция заменяется на эквивалентную с другим операндом и новой цепочкой индексов.
Если результатом является уже разбитая структура, то будут сгенерированы столько новых обращений, на сколько структур была разбита исходная.


\section{Методология замеров}\label{sec:results/measures}

Тут про замеры графических шейдеров

\section{Результаты замеров}\label{sec:results/results}

\subsection{Результаты ступенчатого понижения}\label{subsec:results/results/lowering}

Результаты сведены в таблицу~\cref{tab:results/lowering}. В ней введены следующие сокращения.

\begin{itemize}
\item \textbf{P} Пакет тестов в ESIMD тестировании
\item \textbf{T} Трансформации приватных операций
\item \textbf{G} Операции с глобальными объектами
\item \textbf{A} Трансформация агрегатных типов
\item \textbf{M} Понижение уровня операций работы с памятью
\item \textbf{Pass} Пакет начал проходить с новым конвеером
\end{itemize}

\begin{table}[!h]
    \centering
    \captionsetup{justification=centering}
    \caption{Результаты ступенчатого понижения}\label{tab:results/lowering}
    \begin{tabular}{|p{0.24\linewidth}|p{0.1\linewidth}|p{0.1\linewidth}|p{0.1\linewidth}|p{0.1\linewidth}|p{0.1\linewidth}|}
        \hline
        P & T & G & A & M & Pass \\ \hline        
        glob   & \verb|+| & \verb|+| & \verb|-| & \verb|-| & \verb|+| \\ \hline
        dpas   & \verb|+| & \verb|-| & \verb|+| & \verb|+| & \verb|+| \\ \hline
        lsc    & \verb|+| & \verb|-| & \verb|+| & \verb|-| & \verb|~| \\ \hline
        atomic & \verb|-| & \verb|+| & \verb|-| & \verb|+| & \verb|~| \\ \hline
        slm    & \verb|-| & \verb|-| & \verb|-| & \verb|+| & \verb|+| \\ \hline
        vec\_arg\_call\_conv & 
                 \verb|+| & \verb|+| & \verb|-| & \verb|-| & \verb|+| \\ \hline
        gather\_scatter    & 
                 \verb|-| & \verb|-| & \verb|+| & \verb|+| & \verb|+| \\ \hline
        ctor\_codegen      & 
                 \verb|-| & \verb|-| & \verb|-| & \verb|+| & \verb|+| \\ \hline
        simd\_copy & 
                 \verb|+| & \verb|+| & \verb|-| & \verb|+| & \verb|~| \\ \hline
    \end{tabular}
\end{table}

\subsection{Результаты разбиения структур}\label{subsec:results/results/splitter}

Для тестирования алгоритма разбиения структур использовались приложения из открытого стека рендеринга Intel (OSPray, Embree). Была оценена корректность алгоритма (прошли все тесты) и его положительное влияние на производительность скомпилированной программы.

Результаты сведены в таблицу~\cref{tab:results/splitter}.

\begin{table}
    \centering
    \captionsetup{justification=centering}
    \caption{Результаты разбиения структур}\label{tab:results/splitter}
    \begin{tabular}{llc|llc}
        \toprule
        Бенчмарк & Результат & Результат \\
        \midrule
        Первый   & \verb|+|  & \verb|+|  \\
        Второй   & \verb| |  & \verb|+|  \\
        Третий   & \verb|+|  & \verb| |  \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{Результаты восстановления векторного потока управления}\label{subsec:results/results/simdcf}

Результаты сведены в таблицу~\cref{tab:results/simdcf}.

\begin{table}
    \centering
    \captionsetup{justification=centering}
    \caption{Результаты восстановления векторного потока управления}\label{tab:results/simdcf}
    \begin{tabular}{llc|llc}
        \toprule
        Бенчмарк & Результат & Результат \\
        \midrule
        Первый   & \verb|+|  & \verb|+|  \\
        Второй   & \verb| |  & \verb|+|  \\
        Третий   & \verb|+|  & \verb| |  \\
        \bottomrule
    \end{tabular}
\end{table}

\section{Выводы}\label{sec:results/outcome}

В третьей главе описываются детали реализации и результаты экспеиментов.

Сначала описывается компиляторная инфраструктура LLVM в которой далее проводятся все эксперименты. Далее описываются особенности графического компилятора IGC и его место в графическом стеке. Отдельно рассматриваются вопросы замеров результатов исполнения шейдерного кода и описывается методология их получения и аппаратная поддержка для этого в современных архитектурах.

Далее описываются основные результаты экспериментов. Результаты применения метода ступенчатого понижения состоят в функциональной корректности работы пакетов тестов. Результаты алгоритмов разбиения структур и восстановления векторного потока управления это улучшение производительности приложений.

\FloatBarrier